!_TAG_FILE_SORTED	2	/0=unsorted, 1=sorted, 2=foldcase/
ARITH_OP	/Users/samflattery/dev/sudoCode/tokens.hpp	/^	ARITH_OP,$/;"	e	language:C++	enum:Kind
ASSIGN	/Users/samflattery/dev/sudoCode/tokens.hpp	/^	ASSIGN,$/;"	e	language:C++	enum:Kind
BOOL	/Users/samflattery/dev/sudoCode/tokens.hpp	/^	BOOL,$/;"	e	language:C++	enum:Kind
BOOL_OP	/Users/samflattery/dev/sudoCode/tokens.hpp	/^	BOOL_OP,$/;"	e	language:C++	enum:Kind
CALLD	/Users/samflattery/dev/sudoCode/tokens.hpp	/^	CALLD,$/;"	e	language:C++	enum:Kind
CC	/Users/samflattery/dev/sudoCode/Makefile	/^CC = gcc$/;"	m	language:Make
CHAR	/Users/samflattery/dev/sudoCode/tokens.hpp	/^	CHAR,$/;"	e	language:C++	enum:Kind
close_file	/Users/samflattery/dev/sudoCode/reader.cpp	/^bool Reader::close_file() {$/;"	f	language:C++	class:Reader
close_file	/Users/samflattery/dev/sudoCode/reader.h	/^	bool close_file();$/;"	p	language:C++	class:Reader
close_file	/Users/samflattery/dev/sudoCode/reader.hpp	/^	bool close_file();$/;"	p	language:C++	class:Reader
COMP_OP	/Users/samflattery/dev/sudoCode/tokens.hpp	/^	COMP_OP,$/;"	e	language:C++	enum:Kind
COND_STMT	/Users/samflattery/dev/sudoCode/tokens.hpp	/^	COND_STMT,$/;"	e	language:C++	enum:Kind
CXX	/Users/samflattery/dev/sudoCode/Makefile	/^CXX = g++-9$/;"	m	language:Make
CXXFLAGS	/Users/samflattery/dev/sudoCode/Makefile	/^CXXFLAGS = -g -Og -Wall -std=c++17$/;"	m	language:Make
DECLR	/Users/samflattery/dev/sudoCode/tokens.hpp	/^	DECLR,$/;"	e	language:C++	enum:Kind
DEPS	/Users/samflattery/dev/sudoCode/Makefile	/^DEPS = lexer.hpp dfa.hpp tokens.hpp reader.hpp$/;"	m	language:Make
DFA	/Users/samflattery/dev/sudoCode/dfa.hpp	/^class DFA {$/;"	c	language:C++
EOL	/Users/samflattery/dev/sudoCode/tokens.hpp	/^	EOL,$/;"	e	language:C++	enum:Kind
fd	/Users/samflattery/dev/sudoCode/reader.h	/^	int fd;$/;"	m	language:C++	class:Reader
filename	/Users/samflattery/dev/sudoCode/reader.h	/^	std::string filename;$/;"	m	language:C++	class:Reader
FOR	/Users/samflattery/dev/sudoCode/tokens.hpp	/^	FOR,$/;"	e	language:C++	enum:Kind
FUNC	/Users/samflattery/dev/sudoCode/tokens.hpp	/^	FUNC,$/;"	e	language:C++	enum:Kind
get_student	/Users/samflattery/dev/sudoCode/test.cpp	/^std::tuple<double, char, std::string> get_student(int id)$/;"	f	language:C++
ID	/Users/samflattery/dev/sudoCode/tokens.hpp	/^	ID,$/;"	e	language:C++	enum:Kind
IN	/Users/samflattery/dev/sudoCode/tokens.hpp	/^	IN$/;"	e	language:C++	enum:Kind
INT	/Users/samflattery/dev/sudoCode/tokens.hpp	/^	INT,$/;"	e	language:C++	enum:Kind
is_name	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^	bool is_name();$/;"	p	language:C++	class:Lexer	file:
is_name	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^bool Lexer::is_name() {$/;"	f	language:C++	class:Lexer
is_number	/Users/samflattery/dev/sudoCode/lexer.cpp	/^bool is_number(string& s) {$/;"	f	language:C++
is_number	/Users/samflattery/dev/sudoCode/lexer.hpp	/^	bool is_number(string& s);$/;"	p	language:C++	class:Lexer
is_number	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^bool is_number(string& s) {$/;"	f	language:C++
kind	/Users/samflattery/dev/sudoCode/dfa.hpp	/^	Kind kind;$/;"	m	language:C++	struct:state
kind	/Users/samflattery/dev/sudoCode/tokens.hpp	/^	Kind kind;$/;"	m	language:C++	struct:Token
Kind	/Users/samflattery/dev/sudoCode/tokens.hpp	/^enum Kind {$/;"	g	language:C++
length	/Users/samflattery/dev/sudoCode/reader.h	/^	bool map_file(&length);$/;"	m	language:C++	class:Reader
lexeme	/Users/samflattery/dev/sudoCode/dfa.hpp	/^	string lexeme;$/;"	m	language:C++	struct:state
lexeme	/Users/samflattery/dev/sudoCode/tokens.hpp	/^	std::string lexeme;$/;"	m	language:C++	struct:Token
Lexer	/Users/samflattery/dev/sudoCode/lexer.hpp	/^	Lexer(const char *str) : m_str(str) { }$/;"	f	language:C++	class:Lexer
Lexer	/Users/samflattery/dev/sudoCode/lexer.hpp	/^class Lexer {$/;"	c	language:C++
Lexer	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^	Lexer(std::string str) {$/;"	f	language:C++	class:Lexer
Lexer	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^class Lexer {$/;"	c	language:C++	file:
LITERAL	/Users/samflattery/dev/sudoCode/tokens.hpp	/^	LITERAL,$/;"	e	language:C++	enum:Kind
main	/Users/samflattery/dev/sudoCode/lexer.cpp	/^int main() {$/;"	f	language:C++
main	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^int main() {$/;"	f	language:C++
main	/Users/samflattery/dev/sudoCode/test.cpp	/^int main()$/;"	f	language:C++
MAIN	/Users/samflattery/dev/sudoCode/tokens.hpp	/^	MAIN,$/;"	e	language:C++	enum:Kind
m_closed	/Users/samflattery/dev/sudoCode/reader.hpp	/^	bool m_closed;$/;"	m	language:C++	class:Reader
m_dfa	/Users/samflattery/dev/sudoCode/lexer.hpp	/^	DFA m_dfa;$/;"	m	language:C++	class:Lexer
m_fd	/Users/samflattery/dev/sudoCode/reader.hpp	/^	int m_fd;$/;"	m	language:C++	class:Reader
m_filename	/Users/samflattery/dev/sudoCode/reader.hpp	/^	char* m_filename;$/;"	m	language:C++	class:Reader
m_file_addr	/Users/samflattery/dev/sudoCode/reader.hpp	/^	char *m_file_addr;$/;"	m	language:C++	class:Reader
m_length	/Users/samflattery/dev/sudoCode/reader.hpp	/^	size_t m_length;$/;"	m	language:C++	class:Reader
m_ss	/Users/samflattery/dev/sudoCode/lexer.hpp	/^	std::stringstream m_ss;$/;"	m	language:C++	class:Lexer
m_ss	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^	std::stringstream m_ss;$/;"	m	language:C++	class:Lexer	file:
m_states	/Users/samflattery/dev/sudoCode/dfa.hpp	/^	vector<struct state> m_states;$/;"	m	language:C++	class:DFA
m_states	/Users/samflattery/dev/sudoCode/lexer.hpp	/^	vector<struct state> m_states;$/;"	m	language:C++	class:Lexer
m_str	/Users/samflattery/dev/sudoCode/lexer.hpp	/^	const char *m_str;$/;"	m	language:C++	class:Lexer
m_str	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^	char *m_str;$/;"	m	language:C++	class:Lexer	file:
m_tokens	/Users/samflattery/dev/sudoCode/lexer.hpp	/^	vector<struct Token> m_tokens;$/;"	m	language:C++	class:Lexer
m_tokens	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^	vector<Token> m_tokens;$/;"	m	language:C++	class:Lexer	file:
next	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^	bool next();$/;"	p	language:C++	class:Lexer	file:
OBJ	/Users/samflattery/dev/sudoCode/Makefile	/^OBJ = lexer.o dfa.o$/;"	m	language:Make
operator <<	/Users/samflattery/dev/sudoCode/lexer.cpp	/^std::ostream& operator<<(std::ostream &os, const Kind &k) {$/;"	f	language:C++
operator <<	/Users/samflattery/dev/sudoCode/lexer.cpp	/^std::ostream& operator<<(std::ostream &os, const Token &t) {$/;"	f	language:C++
operator <<	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^std::ostream& operator<<(std::ostream &os, const Kind &k) {$/;"	f	language:C++
operator <<	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^std::ostream& operator<<(std::ostream &os, const Token &t) {$/;"	f	language:C++
parse_declaration	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^	bool parse_declaration();$/;"	p	language:C++	class:Lexer	file:
parse_declaration	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^bool Lexer::parse_declaration() {$/;"	f	language:C++	class:Lexer
parse_eol	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^	bool parse_eol();$/;"	p	language:C++	class:Lexer	file:
parse_eol	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^bool Lexer::parse_eol() {$/;"	f	language:C++	class:Lexer
parse_eval	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^	bool parse_eval();$/;"	p	language:C++	class:Lexer	file:
parse_eval	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^bool Lexer::parse_eval() {$/;"	f	language:C++	class:Lexer
parse_literal	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^	bool parse_literal();$/;"	p	language:C++	class:Lexer	file:
parse_literal	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^bool Lexer::parse_literal() {$/;"	f	language:C++	class:Lexer
parse_operator	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^	bool parse_operator();$/;"	p	language:C++	class:Lexer	file:
parse_operator	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^bool Lexer::parse_operator() {$/;"	f	language:C++	class:Lexer
parse_token	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^	bool parse_token();$/;"	p	language:C++	class:Lexer	file:
parse_token	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^bool Lexer::parse_token() {$/;"	f	language:C++	class:Lexer
parse_tokens	/Users/samflattery/dev/sudoCode/lexer.cpp	/^vector<Token> Lexer::parse_tokens() {$/;"	f	language:C++	class:Lexer
parse_tokens	/Users/samflattery/dev/sudoCode/lexer.hpp	/^	vector<struct Token> parse_tokens();$/;"	p	language:C++	class:Lexer
parse_tokens	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^	vector<Token> parse_tokens();$/;"	p	language:C++	class:Lexer	file:
parse_tokens	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^vector<Token> Lexer::parse_tokens() {$/;"	f	language:C++	class:Lexer
parse_type	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^	bool parse_type();$/;"	p	language:C++	class:Lexer	file:
parse_type	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^bool Lexer::parse_type() {$/;"	f	language:C++	class:Lexer
parse_word	/Users/samflattery/dev/sudoCode/lexer.cpp	/^bool Lexer::parse_word() {$/;"	f	language:C++	class:Lexer
parse_word	/Users/samflattery/dev/sudoCode/lexer.hpp	/^	bool parse_word();$/;"	p	language:C++	class:Lexer
PRINT	/Users/samflattery/dev/sudoCode/tokens.hpp	/^	PRINT,$/;"	e	language:C++	enum:Kind
Reader	/Users/samflattery/dev/sudoCode/reader.cpp	/^Reader::Reader(std::string filename) {$/;"	f	language:C++	class:Reader
Reader	/Users/samflattery/dev/sudoCode/reader.h	/^class Reader {$/;"	c	language:C++
Reader	/Users/samflattery/dev/sudoCode/reader.hpp	/^	Reader(std::string filename);$/;"	p	language:C++	class:Reader
Reader	/Users/samflattery/dev/sudoCode/reader.hpp	/^class Reader {$/;"	c	language:C++
read_file	/Users/samflattery/dev/sudoCode/reader.cpp	/^const char *Reader::read_file(size_t &length) {$/;"	f	language:C++	class:Reader
read_file	/Users/samflattery/dev/sudoCode/reader.h	/^	const char *read_file(std::string filename);$/;"	p	language:C++	class:Reader
read_file	/Users/samflattery/dev/sudoCode/reader.hpp	/^	const char *read_file(size_t &length);$/;"	p	language:C++	class:Reader
recognize_string	/Users/samflattery/dev/sudoCode/dfa.cpp	/^bool DFA::recognize_string(const char*& c, struct Token& tok) {$/;"	f	language:C++	class:DFA
recognize_string	/Users/samflattery/dev/sudoCode/dfa.hpp	/^	bool recognize_string(const char*& s, struct Token& tok);$/;"	p	language:C++	class:DFA
register_declarations	/Users/samflattery/dev/sudoCode/lexer.cpp	/^void Lexer::register_declarations() {$/;"	f	language:C++	class:Lexer
register_declarations	/Users/samflattery/dev/sudoCode/lexer.hpp	/^	void register_declarations();$/;"	p	language:C++	class:Lexer
register_eol	/Users/samflattery/dev/sudoCode/lexer.cpp	/^void Lexer::register_eol() {$/;"	f	language:C++	class:Lexer
register_eol	/Users/samflattery/dev/sudoCode/lexer.hpp	/^	void register_eol();$/;"	p	language:C++	class:Lexer
register_operators	/Users/samflattery/dev/sudoCode/lexer.cpp	/^void Lexer::register_operators() {$/;"	f	language:C++	class:Lexer
register_operators	/Users/samflattery/dev/sudoCode/lexer.hpp	/^	void register_operators();$/;"	p	language:C++	class:Lexer
register_state	/Users/samflattery/dev/sudoCode/dfa.cpp	/^void DFA::register_state(struct state &st) {$/;"	f	language:C++	class:DFA
register_state	/Users/samflattery/dev/sudoCode/dfa.hpp	/^	void register_state(struct state& st);$/;"	p	language:C++	class:DFA
register_states	/Users/samflattery/dev/sudoCode/dfa.cpp	/^void DFA::register_states(vector<struct state>& states) {$/;"	f	language:C++	class:DFA
register_states	/Users/samflattery/dev/sudoCode/dfa.hpp	/^	void register_states(vector<struct state>& states);$/;"	p	language:C++	class:DFA
register_states	/Users/samflattery/dev/sudoCode/lexer.cpp	/^void Lexer::register_states() {$/;"	f	language:C++	class:Lexer
register_states	/Users/samflattery/dev/sudoCode/lexer.hpp	/^	void register_states();$/;"	p	language:C++	class:Lexer
register_types	/Users/samflattery/dev/sudoCode/lexer.cpp	/^void Lexer::register_types() {$/;"	f	language:C++	class:Lexer
register_types	/Users/samflattery/dev/sudoCode/lexer.hpp	/^	void register_types();$/;"	p	language:C++	class:Lexer
state	/Users/samflattery/dev/sudoCode/dfa.hpp	/^struct state {$/;"	s	language:C++
str	/Users/samflattery/dev/sudoCode/dfa.hpp	/^	string str;$/;"	m	language:C++	struct:state
stream_has_string	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^	bool stream_has_string(string str);$/;"	p	language:C++	class:Lexer	file:
stream_has_string	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^bool Lexer::stream_has_string(string str) {$/;"	f	language:C++	class:Lexer
STRING	/Users/samflattery/dev/sudoCode/tokens.hpp	/^	STRING,$/;"	e	language:C++	enum:Kind
Token	/Users/samflattery/dev/sudoCode/tokens.hpp	/^struct Token {$/;"	s	language:C++
WHILE	/Users/samflattery/dev/sudoCode/tokens.hpp	/^	WHILE,$/;"	e	language:C++	enum:Kind
__TOKENS_H__	/Users/samflattery/dev/sudoCode/tokens.hpp	/^#define __TOKENS_H__$/;"	d	language:C++
~Lexer	/Users/samflattery/dev/sudoCode/lexer.hpp	/^	~Lexer() {$/;"	f	language:C++	class:Lexer
~Lexer	/Users/samflattery/dev/sudoCode/string-lex.cpp	/^	~Lexer() {$/;"	f	language:C++	class:Lexer
~Reader	/Users/samflattery/dev/sudoCode/reader.cpp	/^Reader::~Reader() {$/;"	f	language:C++	class:Reader
~Reader	/Users/samflattery/dev/sudoCode/reader.hpp	/^	~Reader();$/;"	p	language:C++	class:Reader
